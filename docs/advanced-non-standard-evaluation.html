<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Non-Standard Evaluation</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 60px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 65px;
  margin-top: -65px;
}

.section h2 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h3 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h4 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h5 {
  padding-top: 65px;
  margin-top: -65px;
}
.section h6 {
  padding-top: 65px;
  margin-top: -65px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">R Best Practice</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="software.html">Software</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Writing
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="writing-style.html">Style</a>
    </li>
    <li>
      <a href="writing-structure.html">Structure</a>
    </li>
    <li>
      <a href="writing-rmarkdown.html">R Markdown</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="packages-wrangling.html">Data Wrangling</a>
    </li>
    <li>
      <a href="packages-modelling.html">Modelling</a>
    </li>
    <li>
      <a href="packages-visualisation.html">Visualisation</a>
    </li>
    <li>
      <a href="packages-optimisation.html">Optimisation</a>
    </li>
    <li>
      <a href="packages-development.html">Package development</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Development
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="development-version-control.html">Version Control</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Advanced
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="advanced-non-standard-evaluation.html">Non-Standard Evaluation</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="cheatsheets.html">Cheatsheets</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Non-Standard Evaluation</h1>

</div>


<p>Non-standard evaluation is a catch-all term that means they don’t follow the usual R rules of evaluation. Instead, they capture the expression that you typed and evaluate it in a custom way.</p>
<div id="strings-and-quoting" class="section level2">
<h2>Strings and quoting</h2>
<p>Here’s a simple example in the case of strings. If you want to return a personalised message, it is obvious the below function will not give you what you want:</p>
<pre class="r"><code>greet &lt;- function(name) {
  &quot;Hello, name&quot;
}

greet(&quot;Bob&quot;)</code></pre>
<pre><code>## [1] &quot;Hello, name&quot;</code></pre>
<p>The function returns the string exactly as it is written because it is in quotes. With the <a href="https://www.rdocumentation.org/packages/glue"><code>glue</code></a> package you can use non-standard evaluation to return what you want:</p>
<pre class="r"><code>greet &lt;- function(name) {
  glue(&quot;Hello, {name}&quot;)
}

greet(&quot;Bob&quot;)</code></pre>
<pre><code>## Hello, Bob</code></pre>
<p>The <a href="https://www.rdocumentation.org/packages/glue/topics/glue"><code>glue()</code></a> function “unquotes” the “name” and evaluates it as a variable.</p>
</div>
<div id="base-r-evaluation" class="section level2">
<h2>Base R evaluation</h2>
<div id="expressions-and-quoting" class="section level4">
<h4>Expressions and quoting</h4>
<p>A similar approach can be taken to more general expressions in R. An <strong>expression</strong> is some R code has not been evaluated yet. It is captured and saved for later. In base R this can be achieved using the <a href="https://www.rdocumentation.org/packages/base/topics/substitute"><code>quote()</code></a> function. Expressions can be one of four classes:</p>
<ul>
<li>“constants” (e.g. 4, TRUE).</li>
<li>“names” (e.g. variable names), that have type “symbols”.</li>
<li>“calls” (e.g. unevaluated function calls), that have type “language”.</li>
<li>“pairlists” (not really used anymore).</li>
</ul>
<p>Constants are not very interesting, so we will concentrate on names and calls. As with strings, we can capture the expression, rather than the evaluated result, using the <a href="https://www.rdocumentation.org/packages/base/topics/substitute"><code>quote()</code></a> function:</p>
<pre class="r"><code>quote(x) %&gt;% class()</code></pre>
<pre><code>## [1] &quot;name&quot;</code></pre>
<pre class="r"><code>quote(mean(1:10)) %&gt;% class()</code></pre>
<pre><code>## [1] &quot;call&quot;</code></pre>
<p>To evaluate a quoted expression use the <a href="https://www.rdocumentation.org/packages/base/topics/eval"><code>eval()</code></a> function:</p>
<pre class="r"><code>x &lt;- 10

quote(x) %&gt;% eval()</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>quote(mean(1:10)) %&gt;% eval()</code></pre>
<pre><code>## [1] 5.5</code></pre>
</div>
<div id="names-and-environments" class="section level4">
<h4>Names and Environments</h4>
<p>An <strong>environment</strong> is a container for variables, binding a set of names to a set of values. Every environment also has a parent environment, except the <strong>empty</strong> environment, which is the ultimate ancester of all environments. If a name is not found in the current environment R looks in its parent and so on through the generations. This is known as <strong>lexical scoping</strong>.</p>
<p>When using <code>eval()</code> as above the expression is evaluated in the current environment. However, the environment to evaluate the expression in can be set as a parameter to <code>eval()</code>.</p>
<p>Note: <code>data.frames</code> can be treated as environments containing the column names binded to the column vectors.</p>
</div>
<div id="calls" class="section level4">
<h4>Calls</h4>
<p>A <strong>call</strong> is a delayed evaluation of a function call. The function and the argument names are stored, but not evaluated. So you can change the values associated with the arguments before evaluation. In fact they need not be defined at creation time at all:</p>
<pre class="r"><code>wait_for_it &lt;- quote(x + y)

x &lt;- 3
y &lt;- 8

eval(wait_for_it)</code></pre>
<pre><code>## [1] 11</code></pre>
</div>
<div id="parsing-and-deparsing" class="section level4">
<h4>Parsing and Deparsing</h4>
<p><strong>Parsing</strong> turns text into expressions and <strong>deparsing</strong> turns expressions into text. The <a href="https://www.rdocumentation.org/packages/base/topics/parse"><code>parse()</code></a> function converts text, but its default argument is a file connection, so we must use the text argument:</p>
<pre class="r"><code>parse(text = &quot;8 + 10&quot;) %&gt;% eval()</code></pre>
<pre><code>## [1] 18</code></pre>
<p>Deparse might be useful for returning information to the user:</p>
<pre class="r"><code>friendly_eval &lt;- function(expr) {
  str_c(&quot;The value of &quot;, deparse(expr), &quot; is &quot;, eval(expr))
}

quote(8 + 10) %&gt;% friendly_eval()</code></pre>
<pre><code>## [1] &quot;The value of 8 + 10 is 18&quot;</code></pre>
</div>
<div id="functions-and-closures" class="section level4">
<h4>Functions and closures</h4>
<p>When you execute a function it creates a new, temporary, environment. The named arguments to the function, plus any variables created within its body are stored in this environment. Thus it cannot effect the variables outside its scope.</p>
<p>The parent for the function’s environment is the environment in which the function was created in, not the one in which it was executed in. Thus it has access to all the variables in the parent environment. This is known as <strong>closure</strong>, as it <em>encloses</em> the parent environment, and can be a powerful tool.</p>
</div>
<div id="substitute-and-promise" class="section level4">
<h4>Substitute and promise</h4>
<p>The <code>friendly_eval()</code> function above requires its argument to be quoted. It would be nice if we could write the expression directly as an argument. However, <code>quote()</code> makes a literal quote of its input, in this case <code>expr</code>. What we need is <a href="https://www.rdocumentation.org/packages/base/topics/substitute"><code>substitute()</code></a>. This will lookup all the object names provided to it, and if it finds a value for that name, it will substitute the name for its value:</p>
<pre class="r"><code>friendly_eval &lt;- function(expr) {
  expr_sub &lt;- substitute(expr)
  str_c(&quot;The value of &quot;, deparse(expr_sub), &quot; is &quot;, eval(expr_sub))
}

friendly_eval(8 + 10)</code></pre>
<pre><code>## [1] &quot;The value of 8 + 10 is 18&quot;</code></pre>
<p>The above function only works because in R function arguments are evaluated lazily – variables are not evaluated until they are used. R stores arguments as a <strong>promise</strong>, which contains the expression of an argument along with the value. <code>substitute()</code> capture the expression before it is evaluated.</p>
</div>
<div id="formula-and-overscoping" class="section level4">
<h4>Formula and overscoping</h4>
<p>A <strong>formula</strong> is a <em>domain specific language</em> (DSL) to simplify expressing the relationship between variables. Just like functions, formulas enclose the environment they are created in. When a formula is evaluated later in a different environment, it can still access all the objects that lived in its original environment.</p>
<p>If an object exists in more than one accessible environment the enviroment the formula (or function) is evaluated in takes precidence. If the object is not found, R looks in the enclosed environment. This is known as <strong>overscoping</strong>, as the formula or function has scope beyond its execution environment.</p>
</div>
</div>
<div id="tidy-evaluation" class="section level2">
<h2>Tidy Evaluation</h2>
<p>To summarise the above, the following points are important to tidy evaluation:</p>
<ol style="list-style-type: decimal">
<li><code>quote()</code> delays evaluation of an expression.</li>
<li><code>eval()</code> evaluates an expression in the current (or a specified) environment.</li>
</ol>
<p>Functions and formulas:</p>
<ol start="3" style="list-style-type: decimal">
<li>enclose the environment they were created in.</li>
<li>evaluate objects in their own, and enclosed, environments</li>
</ol>
<p>Tidy evaluation has two new additions: <strong>quasiquotation</strong> and <strong>quosures</strong>.</p>
<div id="quasiquotation" class="section level4">
<h4>Quasiquotation</h4>
<p><strong>Quasiquotation</strong> enables the user to evaluate parts of the expression right away, while quoting the rest. Say we have the expression <code>z - x + 4</code> and we know the value of <code>x</code> at the time of quoting, we can <strong>unquote</strong> <code>x</code> with the function <a href="http://rlang.tidyverse.org/reference/quasiquotation.html"><code>UQ()</code></a> or the operator <a href="http://rlang.tidyverse.org/reference/quasiquotation.html"><code>!!</code></a>. However, <code>quote()</code> will not work in this quasiquotation, we need to use the tidy evaluation equivalent, <a href="http://rlang.tidyverse.org/reference/expr.html"><code>expr()</code></a>:</p>
<pre class="r"><code>x &lt;- 10

expr(z - UQ(x) + 4)</code></pre>
<pre><code>## z - 10 + 4</code></pre>
<pre class="r"><code>expr(z - !!x + 4) %&gt;% class()</code></pre>
<pre><code>## [1] &quot;call&quot;</code></pre>
<p>The <code>expr()</code> function returns expressions, as does <code>quote()</code>, without any information on the environment it was created in. Some other useful functions for quasiquotation are:</p>
<ul>
<li><a href="http://rlang.tidyverse.org/reference/quasiquotation.html"><code>UQS()</code></a> and the <a href="http://rlang.tidyverse.org/reference/quasiquotation.html"><code>!!!</code></a> operator unquote and splice their arguments.</li>
<li><a href="http://rlang.tidyverse.org/reference/expr.html"><code>enexpr()</code></a> takes an expression, looks up any symbols (names) within it and returns it unevaluated. It is equivalent to <code>substitute()</code>.</li>
<li><a href="http://rlang.tidyverse.org/reference/expr.html"><code>exprs()</code></a> captures multiple expressions and returns a list.</li>
</ul>
</div>
<div id="quosures" class="section level4">
<h4>Quosures</h4>
<p>As the name suggests, <strong>quosures</strong> are hybrids of quotes and closures. They are unevaluated expressions that enclose their creation environment. This is very similar to formulas and they are in fact implemented as one-sided formulas. Quosures are created with the <a href="http://rlang.tidyverse.org/reference/quosure.html"><code>quo()</code></a> function:</p>
<pre class="r"><code>quo(z - UQ(x) + 4)</code></pre>
<pre><code>## &lt;quosure: global&gt;
## ~z - 10 + 4</code></pre>
<pre class="r"><code>quo(z - !!x + 4) %&gt;% class()</code></pre>
<pre><code>## [1] &quot;quosure&quot; &quot;formula&quot;</code></pre>
<p>The quosure equivalent of <code>substitute()</code> is <a href="http://rlang.tidyverse.org/reference/quosure.html"><code>enquo()</code></a>. It takes a symbol referring to a function argument, quotes the R code that was supplied to this argument, captures the environment where the function was called (and thus where the R code was typed), and bundles them in a quosure.</p>
<p>Another useful function is <a href="http://rlang.tidyverse.org/reference/quosure.html"><code>quos()</code></a>, it returns a list of quosures. You can supply several expressions directly, e.g. <code>quos(foo, bar)</code>, but more importantly you can also supply dots: <code>quos(...)</code>.</p>
<p>Note that quosures don’t make a lower level distinction between calls and names. Every expression becomes a quosure.</p>
<p>To evaluate quosures we need a special function to implement the environment scoping properly. <code>rlang</code> provides such a function: <a href="rlang.tidyverse.org/reference/eval_tidy.html"><code>eval_tidy()</code></a></p>
<pre class="r"><code>x &lt;- 10

quo(x) %&gt;% eval_tidy()</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>quo(mean(1:10)) %&gt;% eval_tidy()</code></pre>
<pre><code>## [1] 5.5</code></pre>
</div>
<div id="parsing-and-deparsing-1" class="section level4">
<h4>Parsing and Deparsing</h4>
<p><code>rlang</code> also provides functions for parsing and deparsing expressions. To turn a string into an expression use: - <a href="http://rlang.tidyverse.org/reference/parse_expr.html"><code>parse_expr()</code></a>, which works in the same way as <code>parse(text = ...)</code>. - <a href="http://rlang.tidyverse.org/reference/parse_expr.html"><code>parse_quosure()</code></a> to create a quosure.</p>
<p>To turn an expression into a string, <code>rlang</code> provides two functions: - <a href="http://rlang.tidyverse.org/reference/expr_label.html"><code>expr_text()</code></a> to turn an expression into a string. - <a href="http://rlang.tidyverse.org/reference/expr_label.html"><code>expr_label()</code></a> to produce a string that is more suited to use as a label.</p>
<pre class="r"><code>friendly_eval &lt;- function(expr) {
  str_c(&quot;The value of &quot;, deparse(expr), &quot; is &quot;, eval(expr))
}

quote(8 + 10) %&gt;% friendly_eval()</code></pre>
<pre><code>## [1] &quot;The value of 8 + 10 is 18&quot;</code></pre>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
